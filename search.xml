<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[angular(基础篇-表单)]]></title>
    <url>%2F2018%2F11%2F24%2Fforms%2F</url>
    <content type="text"><![CDATA[angular表单 注意:看到很多模板变量报错的，form表单的模块一定要引入正确，在app.module模块引入并不等于全局模式，所以在引入组件的地方一定引入表单的模块,我是在路由模块引入的，因为我的组件多数都在路由文件中；记得不要放在app.module哪个组件需要form模块，就在引入组件的地方引入下面的模块，最后在元数据中imports 1import &#123; FormsModule,ReactiveFormsModule &#125; from '@angular/forms'; 模板驱动表单(FormsModule)angular封装了处理了表单，这里form和原生的不太一样,表单是经过处理的，不会刷新页面 123456789101112131415161718192021222324252627282930313233&lt;form #myForm='ngForm' (ngSubmit)="onSubmit(myForm.value)" novalidate &gt;'这里的模板变量必须是ngForm，表单的内容会以对象的形式挂载在模板变量的value上' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" ngModel name='username' id="username" //'使用ngModel双向绑定数据，必须要有name属性，这个也是挂载模板变量身上的属性名' class="form-control input-underline input-lg" minlength="4" required placeholder="username" #username="ngModel"&gt; '这里的模板变量可以作为提示的判断' &lt;/div&gt; &lt;div [hidden]="username.valid || username.pristine" //'这个是根据模板变量#username="ngModel" 拿到的值 可作为提示用' class="alert alert-danger"&gt; username is required &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" ngModel name='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div ngModelGroup="passwordGroup"&gt;// 'ngModelGroup是用来分组的，可以把多个分成一组放在myForm.value对象的一个属性上' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" ngModel name='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" ngModel name='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 对象的形式模板表单有三个主要的指令 表单的变量 #myForm=’ngForm’ ngForm不可变， ngModel 双向数据绑定，记得name属性ngModelGroup=”passwordGroup” 这个分组用，个人感觉用处不大。 响应式表单(ReactiveFormsModule)demo-template中 1234567891011121314151617181920212223242526&lt;form [formGroup]="myform" (ngSubmit)="onSubmit()"&gt;'视图和myform关联' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" formControlName="username" id="username" class="form-control input-underline input-lg" minlength="4" required placeholder="Username" &gt; '使用formControlName绑定字段' &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" formControlName='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" formArrayName='emails'&gt; '使用formArrayName分组数据' &lt;ul&gt; &lt;li *ngFor="let email of myform.get('emails').controls; let i=index"&gt;'获取数组数据并循环' 邮箱-&#123;&#123;i+1&#125;&#125; &lt;input type="text" [formControlName]='i' &gt; &lt;/li&gt; '利用索引绑定数据，记得用[],不知道为什么一会要用[]其他又不用，不得不吐槽一下这个坑爹的angular！！！' &lt;/ul&gt; &lt;button (click)="addEmail()"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;div formGroupName='confirm'&gt;'分组' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" formControlName='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" formControlName='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 组件中 12345678910111213141516171819202122231. import &#123;FormBuilder, FormControl, FormGroup, FormArray,Validators&#125; from '@angular/forms'; '引入'2. public myform = new FormGroup(&#123; username: new FormControl(), phone: new FormControl(), confirm:new FormGroup(&#123; password: new FormControl(), confimp: new FormControl(), &#125;), emails:new FormArray([ new FormControl(), ]) &#125;); '声明'3. onSubmit()&#123; console.log(this.myform.value); &#125; '数据挂载this.myform.value，是对象形式'4. addEmail()&#123; let emails = this.myform.get('emails') as FormArray; emails.push(new FormControl()) &#125; '这个感觉也是蛮坑的，获取emails数据不能直接取，要用这种方式！！！' 还有很多内容，包括表单校验，FormBuilder服务，校验的内置方法规则，以及自定义校验规则， 但整体感觉相当繁琐，一点都不实用，这里就不做过多介绍，可以去官方文档研究！ 吐槽一下官方文档：文档内容不是很清晰，坑很多，试错成本较大，而且没有常见问题的说明，个人觉得文档很糟糕！！！]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-路由)]]></title>
    <url>%2F2018%2F11%2F22%2Fbasis-route%2F</url>
    <content type="text"><![CDATA[路由路由配置 123456789101112131415161718192021222324252627&lt;base href="/"&gt; '在index.html的 &lt;head&gt; 标签下先添加一个 &lt;base&gt; 元素，来告诉路由器该如何合成导航用的 URL。'import &#123; RouterModule, Routes &#125; from '@angular/router';'导入router相关模块'const appRoutes: Routes = [ &#123; path: 'hero/:id',component: HeroDetailComponent children:[ &#123; path:'', component: component, &#125;, &#123; path: 'details/:id', component: component, &#125; ] &#125;,'可以用路由传值形如 hero/789' &#123; path: 'heroes',component: HeroListComponent,data: &#123; title: 'Heroes List' &#125; 'data属性存储数据的，' &#125;, &#123; path: '','根路径' redirectTo: '/heroes', pathMatch: 'full' &#125;, &#123; path: '**', component: PageNotFoundComponent &#125;'404路由没匹配上' ];'路由不能有 / 开头' &lt;router-outlet&gt;&lt;/router-outlet&gt; '路由器出口' '说明:如果有子路由跳转要用 ./ 表示子路由' &lt;el-button [routerLink]="['./details',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 路由导航 12345678910111213141516171819202122232425261. &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; '这种静态路由不需要传值的'2. &lt;el-button [routerLink]="['/singerDetail']" [queryParams]="&#123;id:id&#125;" routerLinkActive="active" type="text" size="small" (click)="handle(scope,2)"&gt;详情&lt;/el-button&gt; 'url路径 /singerDetail?id=xxxxxx'this.singerId = this.routerInfo.snapshot.queryParams['id'];'组件中取值'3. &lt;el-button [routerLink]="['/singerDetail',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 'url路径: /singerDetail/xxxxx;注意:这种情况路由中路径设置必须 singerDetail/:id 否则无法匹配无法跳转' this.singerId = this.routerInfo.snapshot.params['id'];'组件中取值' '以上是在模板中绑定跳转'4. this.router.navigate(['/singerDetail'],&#123;queryParams:&#123; id: this.id &#125;&#125;); 'js跳转，和2效果相同组件中取值也是一样' this.router.navigate(['/singerDetail',this.id]);'这个和3效果相同，路由配置也必须一样' '说明: snapshot快照模式，假如你很确定这个组件的实例永远、永远不会被复用，那就可以使用快照， 但是：假如在同一个组件有两个按钮都是去到商品详情点击了第一个按钮并且这个组件没有销毁的情况 下再点击第二个该按钮不会重新创建这个组件的实例的情况下，只是数据传递的不同，这种情况下要使 用订阅模式(subscribe)''以下是两种订阅模式'this.routerInfo.queryParams.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;)'这个对应 /singerDetail?id=xxxxxx' this.routerInfo.params.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;) '这个对应 /singerDetail/xxxxxx' '这两个必须对应，否则取不到传的参数' 路由守卫(生命周期钩子) CanActivate: 处理导航到某个路由的情况（进入路由时触发事件）； CanDeactivate: 处理从当前路由离开时的情况（离开当前路由时触发事件）; Resolve: 在路由激活之前获取路由数据（预加载数据）； 以下为例CanActivate守卫文件 guard.ts 如下图 路由文件 使用 最后一定要在路由文件中实例化路由守卫 CanDeactivate 和上面基本相同不再介绍 Resolve例如：查看商品详情时，预先根据该商品id查询返回数据；防止进入商品组件时获取数据延迟而出现页面空白的情况 123resolve:&#123; //resolve是一个对象， 用法都一样 product : ProductResolve //想传入product,product由ProductResolve生成&#125;&#125;,'在app.route.module路由文件中使用，最后记得实例化 ProductResolve']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-内置模块以及语法)]]></title>
    <url>%2F2018%2F11%2F21%2Fbasis%2F</url>
    <content type="text"><![CDATA[从app.module.ts说起 NgModules模块 NgModule 是一些带有 @NgModule 装饰器的类。@NgModule 装饰器的 imports 数组会告诉 Angular 哪些其它的 NgModule 是当前模块 所需的，一般都是在imports数组中放置一些内置模块以及服务。 CommonModule模块 CommonModule 导出所有基本的 Angular 指令和管道 NgIf(判断)、NgForOf(循环，也可用NgFor)、NgClass(添加删除css类)、NgStyle(修改样式)、NgSwitch(和NgIf类似) 等指令(还有更多)，以及一些 CurrencyPipe(数字转金额),DatePipe(日期格式化),DecimalPipe(数字转字符串) 等管道。 FormsModule , ReactiveFormsModule模块 FormsModule 许多和表单相关的指令，后面会详细介绍，ReactiveFormsModule 构建响应式表单，封装了根据规则提示的表单，后面详细介绍。 BrowserModule模块 BrowserModule 运行在浏览器中必须的模块 HttpClientModule模块 HttpClientModule 和服务器通讯的模块，一般是封装在单独的文件中 BrowserAnimationsModule , NoopAnimationsModule模块 BrowserAnimationsModule 开启动画 NoopAnimationsModule 关闭动画 RouterModule模块 RouterModule 路由相关模块 从最简单的说起 插值表达式 123&lt;p&gt;My current hero is &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;img src="&#123;&#123;imageUrl&#125;&#125;" style="height:30px"&gt;&lt;p&gt;The sum of 1 + 1 is not &#123;&#123;1 + 1 + getVal()&#125;&#125;&lt;/p&gt; 支持简单的表达式，不支持赋值运算符，位运算，自增自减等比较复杂的 事件绑定 123&lt;button (click)="deleteHero()"&gt;Delete&lt;/button&gt;&lt;button (click)="onSave($event)"&gt;Save&lt;/button&gt; '$event事件对象'&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt; 和vue差不多，其实很多框架都比较类似，当然也可以用bind-、on-、bindon-前缀绑定 数据绑定 12345678910111213141516171819&lt;img bind-src="imageUrl"&gt;&lt;img [src]="imageUrl"&gt; '属性绑定等价与上面'&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt; '属性绑定'&lt;div [ngClass]="&#123;'special': isSpecial&#125;"&gt;&lt;/div&gt; '类绑定不会覆盖已有的类，只会添加或删除当前类'&lt;input [(ngModel)]="name"&gt; '双向绑定，官方叫她' &gt;&gt;盒子里放香蕉&lt;button [attr.aria-label]="help"&gt;help&lt;/button&gt; '自定义属性等'&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt; 'css类名不会覆盖已有的类'&lt;button [style.color]="isSpecial ? 'red' : 'green'"&gt; '行内样式'&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt;&lt;app-hero-detail [hero]="currentHero"&gt;&lt;/app-hero-detail&gt; '组件传值，方括号一定要有，否则就是字符串了'&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt; '官方说badCurly有或无会覆盖原有的类 亲测在有[class.special]，[ngClass]同时存在的情况下不会覆盖'&lt;p&gt;&lt;img src="&#123;&#123;heroImageUrl&#125;&#125;"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;img [src]="heroImageUrl"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt; '上面和下面这两种数据绑定作用相同'&lt;p&gt;&lt;span&gt;"&#123;&#123;title&#125;&#125;" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt; 模板绑定是通过 property 和事件来工作的(官方介绍的比较详细可以去看官方文档) 结构模板指令 1234567891011121314151617181920212223242526272829303132333435363738&lt;div *ngIf="isActive"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt; 'if判断，必须带*号'&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/app-hero-detail&gt;'循环'&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123;&#123;i + 1&#125;&#125; - &#123;&#123;hero.name&#125;&#125;&lt;/div&gt;'带索引的 必须声明i否则拿不到索引'&lt;el-menu default-active="1" class="el-menu-vertical-demo" theme="dark"&gt; &lt;el-submenu *ngFor="let menu of menuList" [title]="menu.title"&gt; &lt;ng-container *ngIf = "menu.hasChildren;else menuBlock"&gt; &lt;el-menu-item-group *ngFor="let subMenu of menu.subs" &gt; &lt;el-submenu [title]="subMenu.title"&gt; &lt;el-menu-item *ngFor="let subsMenu of subMenu.subMenu" [to]="subsMenu.index"&gt;&#123;&#123;subsMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu-item-group&gt; &lt;/ng-container&gt; &lt;ng-template #menuBlock&gt; &lt;el-menu-item *ngFor="let subMenu of menu.subs" [to]="subMenu.index"&gt;&#123;&#123;subMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/ng-template&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;'在这种循环和判断的模块中一个元素不能有多个块，上面这个例子，也就是不能把ngIf和ngFor放在同一个元素上否则报错，if判断的else语句使用要用#后面用else的部分'&lt;div *ngFor="let hero of heroes; trackBy: trackByHeroes"&gt; (&#123;&#123;hero.id&#125;&#125;) &#123;&#123;hero.name&#125;&#125;&lt;/div&gt; 'trackBy有点像vue中key但是要声明才能使用'&lt;div [ngSwitch]="currentHero.emotion"&gt; &lt;app-happy-hero *ngSwitchCase="'happy'" [hero]="currentHero"&gt;&lt;/app-happy-hero&gt; &lt;app-sad-hero *ngSwitchCase="'sad'" [hero]="currentHero"&gt;&lt;/app-sad-hero&gt; &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt; &lt;app-unknown-hero *ngSwitchDefault [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt;&lt;/div&gt; 'ngSwitch指令和js一样的写法'&lt;input #phone placeholder="phone number"&gt; '模板变量可以在其他位置拿到这个元素，以#或者ref声明这个变量'&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;'模板变量作用整个模板作用域和循环let声明是不同的' 管道操作符 123456789&lt;div&gt;Title through uppercase pipe: &#123;&#123;title | uppercase&#125;&#125;&lt;/div&gt; '用法|后面跟名字即可'&lt;div&gt;Title through a pipe chain:&#123;&#123;title | uppercase | lowercase&#125;&#125;&lt;/div&gt;'可以有多个'&lt;div&gt;Birthdate: &#123;&#123;currentHero?.birthdate | date:'longDate'&#125;&#125;&lt;/div&gt;'传值'&lt;div&gt;&#123;&#123;currentHero | json&#125;&#125;&lt;/div&gt; '调试可以输出整个对象，数组'&lt;div&gt;The name is &#123;&#123;nullHero?.name&#125;&#125;&lt;/div&gt; '安全操作符，当对象nullHero为null时不会报错，这点比vue做的好，当然也可以多级像a?.b?.c?.d这样多级判断'&lt;div&gt; The marker is &#123;&#123;$any(hero).marker&#125;&#125;&lt;/div&gt; '类型转换函数没用过暂时还不是很清楚，官方说防止类型转换错误']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-文件信息)]]></title>
    <url>%2F2018%2F11%2F12%2Findex%2F</url>
    <content type="text"><![CDATA[文件介绍(angualr-cli生成的项目)生成的项目最外层结构(如图)，主要都集中在src文件夹和angular-cli.json这个文件中 angular-cli.json的主要信息 src目录的主要信息 main.ts入口信息 app目录的主要信息]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular-cli]]></title>
    <url>%2F2018%2F11%2F07%2Fhome%2F</url>
    <content type="text"><![CDATA[写在前面 最近闲着没事，就折腾了一下angular-cli,官方文档anguar-cli, 由于许多东西还在研究，后续持续更新… angular-cli 命令合集项目生成12345$ npm install -g @angular/cli "全局安装"$ ng new myProject "创建新项目 myProject 是项目文件名"$ cd myProject "进入 myProject 文件夹"$ ng server "server/serve都可以，但是我碰到serve启动不成功的情况，这可能和版本更新有关。默认情况下ng会安装依赖，不需要npm install 就可以直接启动"$ ng new myProject --routing "这个命令可以直接生成带有路由的项目，一般都会用的到，当然除了--routing还有其他的参数--prefix组件的前缀" 创建项目具体模块1234567$ ng generate class my-new-class // 新建 class$ ng generate component my-new-component // 新建组件$ ng generate directive my-new-directive // 新建指令$ ng generate enum my-new-enum // 新建枚举$ ng generate module my-new-module // 新建模块$ ng generate pipe my-new-pipe // 新建管道$ ng generate service my-new-service // 新建服务 简写(使用命令的好处是不用在文件来回引入，引入文件很多，很容易遗漏)1234567$ ng g cl my-new-class // 新建 class$ ng g c my-new-component // 新建组件$ ng g d my-new-directive // 新建指令$ ng g e my-new-enum // 新建枚举$ ng g m my-new-module // 新建模块$ ng g p my-new-pipe // 新建管道$ ng g s my-new-service // 新建服务 说明 如果有多个模块，使用命令创建组件要指定组件所属的模块，不指定会默认创建app.module的组件，但是有时候可能会报错。 12$ ng g c my-new-component --module=app-routing // 创建属于路由模块的组件，在路由模块会自动引入该模块$ ng g c my-new-component // 如果不指定模块默认所属在app.module模块中]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular命令</tag>
      </tags>
  </entry>
</search>
