<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[node学习(进阶)]]></title>
    <url>%2F2019%2F01%2F12%2Fnodestudynotes%2Fnodeadvanced%2F</url>
    <content type="text"><![CDATA[node + ejs + express 的使用 项目初始化 npm init -y 安装express、ejs、mysql、 npm i express ejs mysql -S; 在根目录创建入口文件app.js、views文件夹：主要放模板页面，router文件夹：主要放路由相关，controller文件夹：主要放业务逻辑，model文件夹：主要数据操作，static文件夹：主要放静态资源，node_modules主要放npm安装包 目录结构如下app.js 主要开启服务器1234567891011121314151617181920212223242526272829//引入第三方框架expressconst express = require('express');//node的内置模块const path = require('path');//解析请求发送过来的数据let bodyParser = require('body-parser');//开启一个服务let app = express();// 引入模板let ejs = require('ejs');// 设置模板引擎 可以使用html为模板app.engine('.html',ejs.__express);app.set('view engine','html');//设置模板文件存放的路径app.set('views','views');// 解析请求过来的参数 要在路由解析之前注册 req.body这个只针对post请求的，如果是get请求使用req.queryapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json());// 引入路由模块let indexRouter = require('./router/indexRouter.js');//注册路由模块app.use(indexRouter);// 挂载静态资源 静态资源可以挂载多个app.use('/node_modules', express.static(path.join(__dirname, 'node_modules')));app.use('/static', express.static(path.join(__dirname, 'static')));//监听端口app.listen(3000,()=&gt;&#123; console.log('node Server Running at http://127.0.0.1:3000');&#125;) router文件夹 router可以放多个路由模块针对不同的模块 router.js 主要负责路由的分发12345678910111213//主要使用express的路由模块const express = require('express');//路由生成let router = express.Router();// 业务逻辑模块let indexController = require('../controller/indexController.js')//路由模块支持链式调用 后面用的是回调是一个命名函数router.get('/',indexController.showIndexPage) .get('/home',indexController.showHomePage) .post('/user',indexController.showUsers)//最后导出这个模块供app.js使用，module.exports 是node的模块化module.exports = router; controller文件夹 controller文件夹主要放业务逻辑的，也可以分模块放多个模块 以indexController为列：indexController.js 接上面的业务模块1234567891011121314151617181920212223242526272829//引入的数据模块let indexModel = require('../model/indexModel.js');//导出的各个模块module.exports = &#123; //渲染首页的 showIndexPage(req,res)&#123; //获取请求的参数 let params = req.query; console.log('params :', params); indexModel.getAllUsers((err,results)=&gt;&#123; //处理错误的 if(err) return res.render('index',&#123;title:'首页',userList:[&#123;name:'暂时没有数据'&#125;]&#125;) //渲染函数，express已经封装好了 res.render('index',&#123;title:'首页',userList:results&#125;) &#125;) &#125;, showHomePage(req,res)&#123; let params = req.query; console.log('home-get:', params); // console.log('req :', req); res.render('home',&#123;title:'home'&#125;) &#125;, showUsers(req,res)&#123; //解析客户端发送的数据的，也就是body-parser，数据会挂载在req.body上 let params = req.body; console.log('user-post:', params); &#125;&#125; model文件夹 存放和数据库交互的模块数据的存取，更新，增加等 一般我们会抽离成一个基本的配置文件和不同模块的数据 baseDB.js 配置文件 12345678910111213//引入mysql模块，这里使用mysqlvar mysql = require('mysql')//创建一个mysql连接，var connection = mysql.createConnection(&#123;host : 'localhost',//使用本地数据库user : 'root',//数据库的用户名password : 'root',//数据库的密码database : 'users',//数据库的名称&#125;);//连接connection.connect()//导出module.exports = connection; indexModel.js 数据交互 1234567891011121314//引入配置文件创立数据库连接let connection = require('./baseDB');module.exports = &#123; getAllUsers(callback)&#123; //mysql的操作语句，后面单独写 let sqlStr = 'select * from users'; //根据语句查询，这里如果是更新或者其他数据操作，需要业务模块传数据过来 connection.query(sqlStr,(err,result)=&gt;&#123; // console.log(result); if(err) return callback(err); callback(null,result) &#125;) &#125;&#125; 总结 上面的整个过程和之前写过的node(基础) 封装过程差不多，主要是express已经封装好了可以直接拿来用 app.js–&gt;router.js–&gt;controller–&gt;model–&gt;controller–&gt;客户端 说一下如果是自己写写东西用的工具 数据库mysql phpstudy 这个工具挺好用的 navicat premium 这个是数据库可视化工具，可以操作数据库]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习(基础)]]></title>
    <url>%2F2019%2F01%2F12%2Fnodestudynotes%2Fnodebasis%2F</url>
    <content type="text"><![CDATA[node基础 Node.js 基于 Chrome V8 引擎的 javascript 运行环境 我们使用的js写的是node代码，只是单纯的字符串， 如果想要解析这些js代码，必须有一个解析执行环境，这个环境就是chrome的v8引擎 Node.js 的包管理器 npm,是全球最大的开源库生态系统 先使用npm init -y初始化包管理文件package.json,将所有安装的包都记录到这个文件中。 在Node中执行js的两种方式 直接输入node，进入Node的REPL运行环境 R:Read:读取用户输入的字符串内容 E:Evaluate:把用户输入的字符串，当作JS代码解析执行， P:Print:打印输出Evaluate解析的结果 L:Loop:进入下一次循环 将代码写在js文件中，使用node指定文件名运行。 文件操作 如果不指定读取的编码格式，默认data就是一个二进制的Buffer对象(读取文件) 12345let fs = require('fs'); fs.readFile('./demo/1.txt','utf-8',(err,data)=&gt;&#123; if(err) throw err; console.log(data); &#125;); 写入文件不用指定编码，默认就是utf-8,后写入的会把之前的覆盖，如果指定的路径不存在则先创建这个文件，如果文件已存在则直接覆盖这个文件; 1234fs.writeFile('./demo/2.txt','这是写入的内容',err=&gt;&#123; // 写入文件，如果写入成功err是null,否则是一个Error对象； !err&amp;&amp;console.log(err);&#125;) 直接在后面追加内容,如果追加的文件不存在会先创建这个文件 1234fs.appendFile('./demo/2.txt','\n这是appendFile的内容',err=&gt;&#123; // if(err) throw err; console.log(err);&#125;) path 处理模块路径的 一般情况下用的最多的是 path.join(path),path.resolve(path),path.basename(path),path.extname(path) path.join() 返回拼接的路径 如：path.join(&#39;/static&#39;,&#39;img&#39;,&#39;..&#39;) 返回’/static’,..会向上一级抵消掉img目录 path.resolve()方法将路径或路径片段的序列解析为绝对路径。零长度的 path 片段会被忽略。如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径。path.resolve(‘/foo/bar’, ‘./baz’);// 返回: ‘/foo/bar/baz’path.resolve(‘/foo/bar’, ‘/tmp/file/‘);// 返回: ‘/tmp/file’ path.basename() 返回 path 的最后一部分path.basename(‘/foo/bar/baz/asdf/quux.html’);// 返回: ‘quux.html’path.basename(‘/foo/bar/baz/asdf/quux.html’, ‘.html’);// 返回: ‘quux’ path.extname()返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束path.extname(‘index.html’); // 返回: ‘.html’ path.extname(‘index.coffee.md’); // 返回: ‘.md’ path.extname(‘index.’); // 返回: ‘.’ path.extname(‘index’); // 返回: ‘’ path.extname(‘.index’); // 返回: ‘’ http (接下来详细说一下封装的过程) 使用http模块创建一个服务器12345678//引入http模块const http = require('http');const app = http.createServer((req,res)=&gt;&#123; res.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //如果不设置中文会乱码 res.end('test页面')&#125;).listen(3000)# 这样一个简单的服务器就创建好了，但是要想做一个网站应用，这是远远不够的 路由 请求地址，也就是我们的请求路由，这个可以在req,请求体身上拿到123456789101112# 由http的服务器说起const http = require('http');# 引入路由模块const router = require('./router.js');const app = http.createServer((req,res)=&gt;&#123; //我们可以看一下这个请求的路径 下图中可以看到挂载的数据有很多，我只截取我们用到的 # 这样我们就可以看到请求的路径和请求的方法了，这时候我们可以创建一个路由模块，然后把req,res传递过去 这里的req，res贯穿整个应用，可以说是一条线把整个应用连接起来--&gt; 建立router.js router.getRoute(req,res) //res.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //res.end('test')&#125;).listen(3000) router.js(接上面路由模块)1234567891011121314151617 module.exports=&#123; getRoute(req,res)&#123; console.log(req.url); const url = req.url; res.writeHead(200, &#123;'Content-Type':'text/html;charset=utf-8'&#125;) if(url==='/')&#123; res.end('首页') &#125;else&#123; res.end(404) &#125; &#125;&#125;这样一个简单的路由就实现了思路：创建一个服务，我们不能把所有的代码都放到server中，这样的话sever中比较杂乱不好维护既然node是服务端的，我们就借鉴服务端的思想分离router模块形成一个单独的模块更加容易维护httpServer--&gt;router 调用router中的方法就可，下面我们继续抽离业务逻辑模块 controller(业务逻辑) 先说一下后台的思想MVC，M–&gt;(model) 数据层只提供数据怎么使用不管，这样可以保证模块功能单一，只提供数据，一般情况下是mysql,monogodb等获取相关的数据，数据操作，V–&gt;view 页面层也就是我们常说的视图，C–&gt;(controller)也就是我们的业务逻辑层，负责调用model模块获取数据 创建我们的controller.js 123456 module.exports = &#123; showIndexPage(req,res)&#123; res.end('首页') &#125;&#125;//这个模块中我们只写业务逻辑，比如我们渲染页面，返回页面和数据，数据的二次封装等 router.js中引入controller.js 123456789101112131415// 引入controller.js let controller = require(&apos;./controller&apos;); module.exports=&#123; getRoute(req,res)&#123; console.log(req.url); const url = req.url; res.writeHead(200, &#123;&apos;Content-Type&apos;:&apos;text/html;charset=utf-8&apos;&#125;) if(url===&apos;/&apos;)&#123; controller.showIndexPage(req,res) // res.end(&apos;首页&apos;) &#125;else&#123; res.end(404) &#125; &#125; &#125; model层 model是负责数据的，一般是和数据库打交道， 1234567891011121314151617181920 var mysql = require('mysql')var connection = mysql.createConnection(&#123;host : 'localhost',user : 'root',password : 'root',database : 'users'&#125;);connection.connect();//一般情况下我们会把上面的配置内容抽离成一个独立的文件，这样方便改配置 module.exports = &#123; getAllData(callback)&#123; let sqlStr = 'select * from users'; connection.query(sqlStr,(err,result)=&gt;&#123; // console.log(result); if(err) return callback(err); callback(null,result) &#125;) &#125;&#125;//在controller.js中引入这个模块直接调用方法即可 ### 总结：抽离的思路就是MVC思想，各个单一的模块负责各自的功能，更易维护 整体的过程：app(server)–&gt;router(路由分发)–&gt;controller(业务逻辑)–&gt;model(数据相关)这个过程中controller负责向客户端发送页面和数据渲染大致的过程就是这样，框架中封装的思想基本上也是这样，只不过细节到位。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(服务)]]></title>
    <url>%2F2018%2F12%2F21%2Fservice%2F</url>
    <content type="text"></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-cli]]></title>
    <url>%2F2018%2F12%2F12%2Freact%2Freact-cli%2Freact-cli%2F</url>
    <content type="text"></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-表单)]]></title>
    <url>%2F2018%2F11%2F24%2Fforms%2F</url>
    <content type="text"><![CDATA[angular表单 注意:看到很多模板变量报错的，form表单的模块一定要引入正确，在app.module模块引入并不等于全局模式，所以在引入组件的地方一定引入表单的模块,我是在路由模块引入的，因为我的组件多数都在路由文件中；记得不要放在app.module哪个组件需要form模块，就在引入组件的地方引入下面的模块，最后在元数据中imports 1import &#123; FormsModule,ReactiveFormsModule &#125; from '@angular/forms'; 模板驱动表单(FormsModule)angular封装了处理了表单，这里form和原生的不太一样,表单是经过处理的，不会刷新页面 123456789101112131415161718192021222324252627282930313233&lt;form #myForm='ngForm' (ngSubmit)="onSubmit(myForm.value)" novalidate &gt;'这里的模板变量必须是ngForm，表单的内容会以对象的形式挂载在模板变量的value上' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" ngModel name='username' id="username" //'使用ngModel双向绑定数据，必须要有name属性，这个也是挂载模板变量身上的属性名' class="form-control input-underline input-lg" minlength="4" required placeholder="username" #username="ngModel"&gt; '这里的模板变量可以作为提示的判断' &lt;/div&gt; &lt;div [hidden]="username.valid || username.pristine" //'这个是根据模板变量#username="ngModel" 拿到的值 可作为提示用' class="alert alert-danger"&gt; username is required &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" ngModel name='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div ngModelGroup="passwordGroup"&gt;// 'ngModelGroup是用来分组的，可以把多个分成一组放在myForm.value对象的一个属性上' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" ngModel name='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" ngModel name='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 对象的形式模板表单有三个主要的指令 表单的变量 #myForm=’ngForm’ ngForm不可变， ngModel 双向数据绑定，记得name属性ngModelGroup=”passwordGroup” 这个分组用，个人感觉用处不大。 响应式表单(ReactiveFormsModule)demo-template中 1234567891011121314151617181920212223242526&lt;form [formGroup]="myform" (ngSubmit)="onSubmit()"&gt;'视图和myform关联' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" formControlName="username" id="username" class="form-control input-underline input-lg" minlength="4" required placeholder="Username" &gt; '使用formControlName绑定字段' &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" formControlName='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" formArrayName='emails'&gt; '使用formArrayName分组数据' &lt;ul&gt; &lt;li *ngFor="let email of myform.get('emails').controls; let i=index"&gt;'获取数组数据并循环' 邮箱-&#123;&#123;i+1&#125;&#125; &lt;input type="text" [formControlName]='i' &gt; &lt;/li&gt; '利用索引绑定数据，记得用[],不知道为什么一会要用[]其他又不用，不得不吐槽一下这个坑爹的angular！！！' &lt;/ul&gt; &lt;button (click)="addEmail()"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;div formGroupName='confirm'&gt;'分组' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" formControlName='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" formControlName='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 组件中 12345678910111213141516171819202122231. import &#123;FormBuilder, FormControl, FormGroup, FormArray,Validators&#125; from '@angular/forms'; '引入'2. public myform = new FormGroup(&#123; username: new FormControl(), phone: new FormControl(), confirm:new FormGroup(&#123; password: new FormControl(), confimp: new FormControl(), &#125;), emails:new FormArray([ new FormControl(), ]) &#125;); '声明'3. onSubmit()&#123; console.log(this.myform.value); &#125; '数据挂载this.myform.value，是对象形式'4. addEmail()&#123; let emails = this.myform.get('emails') as FormArray; emails.push(new FormControl()) &#125; '这个感觉也是蛮坑的，获取emails数据不能直接取，要用这种方式！！！' 还有很多内容，包括表单校验，FormBuilder服务，校验的内置方法规则，以及自定义校验规则， 但整体感觉相当繁琐，一点都不实用，这里就不做过多介绍，可以去官方文档研究！ 吐槽一下官方文档：文档内容不是很清晰，坑很多，试错成本较大，而且没有常见问题的说明，个人觉得文档很糟糕！！！]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-路由)]]></title>
    <url>%2F2018%2F11%2F22%2Fbasis-route%2F</url>
    <content type="text"><![CDATA[路由路由配置 123456789101112131415161718192021222324252627&lt;base href="/"&gt; '在index.html的 &lt;head&gt; 标签下先添加一个 &lt;base&gt; 元素，来告诉路由器该如何合成导航用的 URL。'import &#123; RouterModule, Routes &#125; from '@angular/router';'导入router相关模块'const appRoutes: Routes = [ &#123; path: 'hero/:id',component: HeroDetailComponent children:[ &#123; path:'', component: component, &#125;, &#123; path: 'details/:id', component: component, &#125; ] &#125;,'可以用路由传值形如 hero/789' &#123; path: 'heroes',component: HeroListComponent,data: &#123; title: 'Heroes List' &#125; 'data属性存储数据的，' &#125;, &#123; path: '','根路径' redirectTo: '/heroes', pathMatch: 'full' &#125;, &#123; path: '**', component: PageNotFoundComponent &#125;'404路由没匹配上' ];'路由不能有 / 开头' &lt;router-outlet&gt;&lt;/router-outlet&gt; '路由器出口' '说明:如果有子路由跳转要用 ./ 表示子路由' &lt;el-button [routerLink]="['./details',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 路由导航 12345678910111213141516171819202122232425261. &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; '这种静态路由不需要传值的'2. &lt;el-button [routerLink]="['/singerDetail']" [queryParams]="&#123;id:id&#125;" routerLinkActive="active" type="text" size="small" (click)="handle(scope,2)"&gt;详情&lt;/el-button&gt; 'url路径 /singerDetail?id=xxxxxx'this.singerId = this.routerInfo.snapshot.queryParams['id'];'组件中取值'3. &lt;el-button [routerLink]="['/singerDetail',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 'url路径: /singerDetail/xxxxx;注意:这种情况路由中路径设置必须 singerDetail/:id 否则无法匹配无法跳转' this.singerId = this.routerInfo.snapshot.params['id'];'组件中取值' '以上是在模板中绑定跳转'4. this.router.navigate(['/singerDetail'],&#123;queryParams:&#123; id: this.id &#125;&#125;); 'js跳转，和2效果相同组件中取值也是一样' this.router.navigate(['/singerDetail',this.id]);'这个和3效果相同，路由配置也必须一样' '说明: snapshot快照模式，假如你很确定这个组件的实例永远、永远不会被复用，那就可以使用快照， 但是：假如在同一个组件有两个按钮都是去到商品详情点击了第一个按钮并且这个组件没有销毁的情况 下再点击第二个该按钮不会重新创建这个组件的实例的情况下，只是数据传递的不同，这种情况下要使 用订阅模式(subscribe)''以下是两种订阅模式'this.routerInfo.queryParams.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;)'这个对应 /singerDetail?id=xxxxxx' this.routerInfo.params.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;) '这个对应 /singerDetail/xxxxxx' '这两个必须对应，否则取不到传的参数' 路由守卫(生命周期钩子) CanActivate: 处理导航到某个路由的情况（进入路由时触发事件）； CanDeactivate: 处理从当前路由离开时的情况（离开当前路由时触发事件）; Resolve: 在路由激活之前获取路由数据（预加载数据）； 以下为例CanActivate守卫文件 guard.ts 如下图 路由文件 使用 最后一定要在路由文件中实例化路由守卫 CanDeactivate 和上面基本相同不再介绍 Resolve例如：查看商品详情时，预先根据该商品id查询返回数据；防止进入商品组件时获取数据延迟而出现页面空白的情况 123resolve:&#123; //resolve是一个对象， 用法都一样 product : ProductResolve //想传入product,product由ProductResolve生成&#125;&#125;,'在app.route.module路由文件中使用，最后记得实例化 ProductResolve']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-内置模块以及语法)]]></title>
    <url>%2F2018%2F11%2F21%2Fbasis%2F</url>
    <content type="text"><![CDATA[从app.module.ts说起 NgModules模块 NgModule 是一些带有 @NgModule 装饰器的类。@NgModule 装饰器的 imports 数组会告诉 Angular 哪些其它的 NgModule 是当前模块 所需的，一般都是在imports数组中放置一些内置模块以及服务。 CommonModule模块 CommonModule 导出所有基本的 Angular 指令和管道 NgIf(判断)、NgForOf(循环，也可用NgFor)、NgClass(添加删除css类)、NgStyle(修改样式)、NgSwitch(和NgIf类似) 等指令(还有更多)，以及一些 CurrencyPipe(数字转金额),DatePipe(日期格式化),DecimalPipe(数字转字符串) 等管道。 FormsModule , ReactiveFormsModule模块 FormsModule 许多和表单相关的指令，后面会详细介绍，ReactiveFormsModule 构建响应式表单，封装了根据规则提示的表单，后面详细介绍。 BrowserModule模块 BrowserModule 运行在浏览器中必须的模块 HttpClientModule模块 HttpClientModule 和服务器通讯的模块，一般是封装在单独的文件中 BrowserAnimationsModule , NoopAnimationsModule模块 BrowserAnimationsModule 开启动画 NoopAnimationsModule 关闭动画 RouterModule模块 RouterModule 路由相关模块 从最简单的说起 插值表达式 123&lt;p&gt;My current hero is &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;img src="&#123;&#123;imageUrl&#125;&#125;" style="height:30px"&gt;&lt;p&gt;The sum of 1 + 1 is not &#123;&#123;1 + 1 + getVal()&#125;&#125;&lt;/p&gt; 支持简单的表达式，不支持赋值运算符，位运算，自增自减等比较复杂的 事件绑定 123&lt;button (click)="deleteHero()"&gt;Delete&lt;/button&gt;&lt;button (click)="onSave($event)"&gt;Save&lt;/button&gt; '$event事件对象'&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt; 和vue差不多，其实很多框架都比较类似，当然也可以用bind-、on-、bindon-前缀绑定 数据绑定 12345678910111213141516171819&lt;img bind-src="imageUrl"&gt;&lt;img [src]="imageUrl"&gt; '属性绑定等价与上面'&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt; '属性绑定'&lt;div [ngClass]="&#123;'special': isSpecial&#125;"&gt;&lt;/div&gt; '类绑定不会覆盖已有的类，只会添加或删除当前类'&lt;input [(ngModel)]="name"&gt; '双向绑定，官方叫她' &gt;&gt;盒子里放香蕉&lt;button [attr.aria-label]="help"&gt;help&lt;/button&gt; '自定义属性等'&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt; 'css类名不会覆盖已有的类'&lt;button [style.color]="isSpecial ? 'red' : 'green'"&gt; '行内样式'&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt;&lt;app-hero-detail [hero]="currentHero"&gt;&lt;/app-hero-detail&gt; '组件传值，方括号一定要有，否则就是字符串了'&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt; '官方说badCurly有或无会覆盖原有的类 亲测在有[class.special]，[ngClass]同时存在的情况下不会覆盖'&lt;p&gt;&lt;img src="&#123;&#123;heroImageUrl&#125;&#125;"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;img [src]="heroImageUrl"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt; '上面和下面这两种数据绑定作用相同'&lt;p&gt;&lt;span&gt;"&#123;&#123;title&#125;&#125;" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt; 模板绑定是通过 property 和事件来工作的(官方介绍的比较详细可以去看官方文档) 结构模板指令 1234567891011121314151617181920212223242526272829303132333435363738&lt;div *ngIf="isActive"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt; 'if判断，必须带*号'&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/app-hero-detail&gt;'循环'&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123;&#123;i + 1&#125;&#125; - &#123;&#123;hero.name&#125;&#125;&lt;/div&gt;'带索引的 必须声明i否则拿不到索引'&lt;el-menu default-active="1" class="el-menu-vertical-demo" theme="dark"&gt; &lt;el-submenu *ngFor="let menu of menuList" [title]="menu.title"&gt; &lt;ng-container *ngIf = "menu.hasChildren;else menuBlock"&gt; &lt;el-menu-item-group *ngFor="let subMenu of menu.subs" &gt; &lt;el-submenu [title]="subMenu.title"&gt; &lt;el-menu-item *ngFor="let subsMenu of subMenu.subMenu" [to]="subsMenu.index"&gt;&#123;&#123;subsMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu-item-group&gt; &lt;/ng-container&gt; &lt;ng-template #menuBlock&gt; &lt;el-menu-item *ngFor="let subMenu of menu.subs" [to]="subMenu.index"&gt;&#123;&#123;subMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/ng-template&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;'在这种循环和判断的模块中一个元素不能有多个块，上面这个例子，也就是不能把ngIf和ngFor放在同一个元素上否则报错，if判断的else语句使用要用#后面用else的部分'&lt;div *ngFor="let hero of heroes; trackBy: trackByHeroes"&gt; (&#123;&#123;hero.id&#125;&#125;) &#123;&#123;hero.name&#125;&#125;&lt;/div&gt; 'trackBy有点像vue中key但是要声明才能使用'&lt;div [ngSwitch]="currentHero.emotion"&gt; &lt;app-happy-hero *ngSwitchCase="'happy'" [hero]="currentHero"&gt;&lt;/app-happy-hero&gt; &lt;app-sad-hero *ngSwitchCase="'sad'" [hero]="currentHero"&gt;&lt;/app-sad-hero&gt; &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt; &lt;app-unknown-hero *ngSwitchDefault [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt;&lt;/div&gt; 'ngSwitch指令和js一样的写法'&lt;input #phone placeholder="phone number"&gt; '模板变量可以在其他位置拿到这个元素，以#或者ref声明这个变量'&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;'模板变量作用整个模板作用域和循环let声明是不同的' 管道操作符 123456789&lt;div&gt;Title through uppercase pipe: &#123;&#123;title | uppercase&#125;&#125;&lt;/div&gt; '用法|后面跟名字即可'&lt;div&gt;Title through a pipe chain:&#123;&#123;title | uppercase | lowercase&#125;&#125;&lt;/div&gt;'可以有多个'&lt;div&gt;Birthdate: &#123;&#123;currentHero?.birthdate | date:'longDate'&#125;&#125;&lt;/div&gt;'传值'&lt;div&gt;&#123;&#123;currentHero | json&#125;&#125;&lt;/div&gt; '调试可以输出整个对象，数组'&lt;div&gt;The name is &#123;&#123;nullHero?.name&#125;&#125;&lt;/div&gt; '安全操作符，当对象nullHero为null时不会报错，这点比vue做的好，当然也可以多级像a?.b?.c?.d这样多级判断'&lt;div&gt; The marker is &#123;&#123;$any(hero).marker&#125;&#125;&lt;/div&gt; '类型转换函数没用过暂时还不是很清楚，官方说防止类型转换错误']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-文件信息)]]></title>
    <url>%2F2018%2F11%2F12%2Findex%2F</url>
    <content type="text"><![CDATA[文件介绍(angualr-cli生成的项目)生成的项目最外层结构(如图)，主要都集中在src文件夹和angular-cli.json这个文件中 angular-cli.json的主要信息 src目录的主要信息 main.ts入口信息 app目录的主要信息]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular-cli]]></title>
    <url>%2F2018%2F11%2F09%2Fhome%2F</url>
    <content type="text"><![CDATA[写在前面 最近闲着没事，就折腾了一下angular-cli,官方文档anguar-cli, 由于许多东西还在研究，后续持续更新… angular-cli 命令合集项目生成12345$ npm install -g @angular/cli "全局安装"$ ng new myProject "创建新项目 myProject 是项目文件名"$ cd myProject "进入 myProject 文件夹"$ ng server "server/serve都可以，但是我碰到serve启动不成功的情况，这可能和版本更新有关。默认情况下ng会安装依赖，不需要npm install 就可以直接启动"$ ng new myProject --routing "这个命令可以直接生成带有路由的项目，一般都会用的到，当然除了--routing还有其他的参数--prefix组件的前缀" 创建项目具体模块1234567$ ng generate class my-new-class // 新建 class$ ng generate component my-new-component // 新建组件$ ng generate directive my-new-directive // 新建指令$ ng generate enum my-new-enum // 新建枚举$ ng generate module my-new-module // 新建模块$ ng generate pipe my-new-pipe // 新建管道$ ng generate service my-new-service // 新建服务 简写(使用命令的好处是不用在文件来回引入，引入文件很多，很容易遗漏)1234567$ ng g cl my-new-class // 新建 class$ ng g c my-new-component // 新建组件$ ng g d my-new-directive // 新建指令$ ng g e my-new-enum // 新建枚举$ ng g m my-new-module // 新建模块$ ng g p my-new-pipe // 新建管道$ ng g s my-new-service // 新建服务 说明 如果有多个模块，使用命令创建组件要指定组件所属的模块，不指定会默认创建app.module的组件，但是有时候可能会报错。 12$ ng g c my-new-component --module=app-routing // 创建属于路由模块的组件，在路由模块会自动引入该模块$ ng g c my-new-component // 如果不指定模块默认所属在app.module模块中]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular命令</tag>
      </tags>
  </entry>
</search>
