<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack配置说明]]></title>
    <url>%2F2019%2F03%2F22%2Fwebpack%2FbaseConfig%2F</url>
    <content type="text"><![CDATA[webpack.base.conf.js(基础配置，一般情况下是生产和开发都要用的) 此配置以react为例配置的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115let path = require('path');const MiniCssExtractPlugin = require("mini-css-extract-plugin");// 拼接绝对路径function resolve(dir)&#123; return path.join(__dirname,'..',dir)&#125;console.log(process.env.NODE_ENV);// 区分环境const isDev = process.env.NODE_ENV==='development';module.exports = &#123; context: path.join(__dirname,'..'),//执行环境 // 入口 entry:&#123; app:'./src/main.js', &#125;, resolve: &#123; extensions: ['.js', '.jsx', '.json'], modules: [ // 指定以下目录寻找第三方模块，避免webpack往父级目录递归搜索 resolve('src'), resolve('node_modules'), ], mainFields: ['main'], // 只采用main字段作为入口文件描述字段，减少搜索步骤 alias: &#123; "@": resolve("src"), // 缓存src目录为@符号，避免重复寻址 // 'react/lib/ReactMount': 'react-dom/lib/ReactMount' &#125; &#125;, module:&#123; rules:[ &#123; test:/\.jsx?$/, exclude: /node_modules/, include:[// 表示只解析以下目录，减少loader处理范围 resolve('src') ], loader: "happypack/loader?id=happy-babel" //开启多进程loader处理的插件的配置 &#125;, // 处理css中的图片 由于目前没有更好的办法处理js和css中的图片路径问题，所以使用两个loader分别处理不同的寻址问题 &#123; test: /\.(png|jpe?g|gif|svg)$/, include:[// 表示只解析以下目录，减少loader处理范围 这里放css中引用的图片 resolve('src/assets') ], use:[ &#123; loader: 'url-loader', options: &#123; limit: 10000, name: 'images/[name].[hash:7].[ext]', publicPath:'../',//这是处理的是css中引用的路径，由于css样式表在css文件夹下，img在images文件夹下，并且css文件夹和images在同一级，所以向上查找一级 outputPath:'static' &#125; &#125;, ] &#125;, // 处理js中的图片 是根据生成html的路径处理的 这样不管是在页面中引入，还是在css中引入都可以正确处理图片路径，但是图片要分开放在不同的文件夹下，如果是css的图片就直接放在assets文件夹下，如果是js中引入就直接放在static中 当然也可以放在同一文件夹下不同的文件内 &#123; test: /\.(png|jpe?g|gif|svg)$/, include:[// 表示只解析以下目录，减少loader处理范围 这里放js中引用的图片 resolve('src/static') ], use:[ &#123; loader: 'url-loader', options: &#123; limit: 10000, name: 'images/[name].[hash:7].[ext]', publicPath:'../static',//这是处理的是js中引用的路径，由于是在js中动态设置，这里页面在pages下面，所以这里要向外翻一级并且在static目录下 outputPath:'static' &#125; &#125;, ] &#125;, // 由于抽离的css在热重载中不生效，所以dev环境采用style标签的方式 &#123; test:/\.css$/, // exclude:/node_modules/, include:[// 表示只解析以下目录，减少loader处理范围 resolve('src'), resolve('node_modules'), ], use:[ &#123; loader:isDev?'style-loader':MiniCssExtractPlugin.loader, options:&#123; //publicPath:'../' ,//这里的路径是以url-loader的路径为主 // outputPath:'../' &#125; &#125;, 'happypack/loader?id=happy-css' ] &#125;, // 处理html中的img标签src引入图片 &#123; test:/\.html$/, use:[ &#123; loader:"html-loader", options:&#123; attrs:["img:src"] //此处的参数值 img是指html中的 &lt;img/&gt; 标签， src是指 img的src属性 表示 html-loader 作用于 img标签中的 src的属性 &#125; &#125; ] &#125;, ] &#125;, plugins: [ // new MiniCssExtractPlugin(&#123; // filename:utils.assetsPath('css/[name].[contenthash].css'), // chunkFilename:utils.assetsPath('css/[id].[contenthash].css') // &#125;) ]&#125; webpack.dev.conf.js(开发环境)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108let path = require('path');// 引入合并配置的插件let merge = require('webpack-merge');let webpackBaseConf = require('./webpack.base.conf');// 生成html插件let htmlWebpackPlugin = require('html-webpack-plugin');// 热重载let webpack = require('webpack');//抽离css的插件const MiniCssExtractPlugin = require("mini-css-extract-plugin");let utils = require('./utils.js');// 开启多进程编译提升编译速度const HappyPack = require('happypack');// 使用HappyPack开启多进程Loader转换const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);const createHappyPlugin = (id, loaders) =&gt; new HappyPack(&#123; id: id, loaders: loaders, threadPool: happyThreadPool, verbose: process.env.HAPPY_VERBOSE === '1' // make happy more verbose with HAPPY_VERBOSE=1&#125;);// 拷贝目录const CopyWebpackPlugin = require('copy-webpack-plugin');module.exports = merge(webpackBaseConf,&#123; mode:'development',//开发环境 //原始代码，更易看到出错的地方 devtool:'eval-source-map', output:&#123; path:path.join(__dirname,'..','dist'),//打包文件夹 filename:'static/js/[name].js',//打包到dist目录下js文件夹下 chunkFilename:'static/js/[id].js' // publicPath:'/' &#125;, devServer:&#123;//开发服务器配置 contentBase: path.join(__dirname,'..', 'dist'), host:'127.0.0.1', hot:true,//开启热重载 port:3000,//访问端口 open:true,//自动打开浏览器， progress:true,//进度， // noInfo:true, historyApiFallback:&#123; rewrites:[ &#123;from:/^\/$/,to:'/pages/index.html'&#125; //这里一定要以 / 开头，在根目录下查找 ] &#125;, proxy:&#123;//代理配置 &#125; &#125;, module:&#123; rules:[ // 处理字体文件 &#123; test: /\.(eot|woff2?|ttf)$/, use: [ &#123; loader:'url-loader', // options: &#123; // name: "[name]-[hash:5].min.[ext]", // limit: 5000, // fonts file size &lt;= 5KB, use 'base64'; else, output svg file // publicPath: "../fonts/",//字体图表向上翻一级在css文件夹的同一级 // outputPath: "static/fonts/"//输出路径 // &#125; &#125; ] &#125; ] &#125;, plugins:[ // new webpack.EnvironmentPlugin(&#123; // NODE_ENV: 'development', // 除非有定义 process.env.NODE_ENV，否则就使用 'development' // DEBUG: false // &#125;), // new webpack.DefinePlugin(&#123; // "process.env":JSON.stringify('development'), // "server_url":JSON.stringify('http://dwy.msyuns.com/') // &#125;), //开发环境下可以不用抽离css new MiniCssExtractPlugin(&#123; filename:'static/css/[name].[contenthash].css', chunkFilename:'static/css/[id].[contenthash].css' &#125;), createHappyPlugin('happy-babel', [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true // 启用缓存 &#125; &#125;]), createHappyPlugin('happy-css', ['css-loader']), // 拷贝文件 主要处理js中和css中图片寻址问题 因为所处文件夹的不同导致无法统一处理，所以采用这种方式 // new CopyWebpackPlugin([ // &#123;from:'src/static/images',to:'static/images'&#125; // ]), // 当接收到热更新信号时，在浏览器console控制台打印更多可读性高的模块名称等信息 new webpack.NamedModulesPlugin(), // 开启webpack全局热更新 new webpack.HotModuleReplacementPlugin(), new htmlWebpackPlugin(&#123; filename:'pages/index.html', template:'./src/pages/index.html', inject:true, &#125;), ]&#125;) webpack.prod.conf.js(生产环境)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147let path = require('path');// 引入合并配置的插件let merge = require('webpack-merge');let webpackBaseConf = require('./webpack.base.conf');// 生成html插件let htmlWebpackPlugin = require('html-webpack-plugin');// 开启多进程编译提升编译速度const HappyPack = require('happypack');// 使用HappyPack开启多进程Loader转换const happyThreadPool = HappyPack.ThreadPool(&#123; size: 5 &#125;);const createHappyPlugin = (id, loaders) =&gt; new HappyPack(&#123; id: id, loaders: loaders, threadPool: happyThreadPool, verbose: process.env.HAPPY_VERBOSE === '1' // make happy more verbose with HAPPY_VERBOSE=1&#125;);// 抽离css的插件const MiniCssExtractPlugin = require("mini-css-extract-plugin");// 压缩css的插件const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');// 压缩js的插件，可以多进程压缩 据说这个没人维护了，问题没人处理所以不用const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');// 有说这个压缩的，但是没找到详细的配置// const TerserPlugin = require('terser-webpack-plugin');// 用官方的压缩插件const UglifyJSPlugin = require('uglifyjs-webpack-plugin');// 拷贝目录const CopyWebpackPlugin = require('copy-webpack-plugin');let utils = require('./utils.js');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = merge(webpackBaseConf,&#123; mode:'production', devtool:'none', output:&#123; path:path.join(__dirname,'..','dist'),//打包文件夹 filename:'static/js/[name].[contenthash:8].js',//打包到dist目录下static/js文件夹下 chunkFilename:'static/js/[id].[contenthash:8].js', publicPath:'../' &#125;, module:&#123; rules:[ // 处理字体文件 &#123; test: /\.(eot|woff2?|ttf)$/, use: [ &#123; loader:"url-loader", options: &#123; name: "[name]-[hash:5].min.[ext]", limit: 5000, // fonts file size &lt;= 5KB, use 'base64'; else, output svg file publicPath: "../fonts/",//字体图表向上翻一级在css文件夹的同一级 outputPath: "static/fonts/"//输出路径 &#125; &#125; ] &#125; ] &#125;, optimization:&#123; // 抽离css的情况下，默认的压缩css的配置失效了，所以需要我们手动压缩 minimizer:[ // 说是这个压缩没人维护了 // new ParallelUglifyPlugin(&#123; // 多进程压缩 // cacheDir: '.cache/', // uglifyJS: &#123; // output: &#123; // comments: false, // beautify: false // &#125;, // compress: &#123; // warnings: false, // drop_console: true, // collapse_vars: true, // reduce_vars: true // &#125; // &#125; // &#125;), ], splitChunks:&#123;//分割代码 chunks: "all", // 共有三个值可选：initial(初始模块)、async(按需加载模块)和all(全部模块) minSize: 30000, // 模块超过30k自动被抽离成公共模块 maxSize:0, minChunks: 1, // 模块被引用&gt;=1次，便分割 maxAsyncRequests: 5, // 异步加载chunk的并发请求数量&lt;=5 maxInitialRequests: 3, // 一个入口并发加载的chunk数量&lt;=3 name: true, // 默认由模块名+hash命名，名称相同时多个模块将合并为1个，可以设置为function automaticNameDelimiter: '~', // 命名分隔符 cacheGroups:&#123;//缓存公共模块 default: &#123; // 模块缓存规则，设置为false，默认缓存组将禁用 minChunks: 2, // 模块被引用&gt;=2次，拆分至vendors公共模块 priority: -20, // 优先级 reuseExistingChunk: true, // 默认使用已有的模块 &#125;, vendors: &#123; test: /[\\/]node_modules[\\/]/, // 表示默认拆分node_modules中的模块 // test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/, 抽离node_modules中的react和react-dom模块 priority: -10 &#125;, &#125; &#125; &#125;, plugins:[ // 打包前删除之前打包的文件夹 new CleanWebpackPlugin(&#123; &#125; ), // 提取css到单独的文件下 new MiniCssExtractPlugin(&#123; filename:'static/css/[name].[contenthash:8].css', chunkFilename:'static/css/[id].[contenthash:8].css' &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;),//这里是压缩css // 采用多进程打包提升打包的速度 createHappyPlugin('happy-babel', [&#123; loader: 'babel-loader', options: &#123; babelrc: true, cacheDirectory: true // 启用缓存 &#125; &#125;]), // 网上有说采用这种方式有转化不完全的可能，但是css目前没有发现有什么问题，less,sass,styl,等没有测试 createHappyPlugin('happy-css', ['css-loader']), // 拷贝文件 主要处理js中和css中图片寻址问题 因为所处文件夹的不同导致无法统一处理，所以采用这种方式 由于是拷贝的文件，未经过loader处理所以js中使用目录以生成的html文件夹为路径寻址 或者 采用loader分开处理不同文件夹下的图片，这里不再采用这种方式，因为根据生成的文件夹处理，没有路径提示，很不方便 // new CopyWebpackPlugin([ // &#123;from:'src/static/images',to:'static/images'&#125; // ]), new UglifyJSPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false,//不显示警告信息 drop_console: true,//console pure_funcs: ['console.log']//移除console &#125; &#125;, // sourceMap: config.build.productionSourceMap, parallel: true//使用多进程并行运行来提高构建速度。默认并发运行次数:os.cpus().length- 1。 &#125;), // 这里html也可以压缩，配置也相当简单，由于是测试就不在配置 new htmlWebpackPlugin(&#123; filename:'pages/index.html', template:'./src/pages/index.html', inject:true, &#125;), ]&#125;) 总结 由于webpack是基于node的，所以在了解node后要更容易学习webpack 在配置中基本的loader配置比较简单，这也是webpack最重要的机制，但是抽离打包上线的优化还是比较繁琐的，包括缓存，抽离公共js,抽离第三方库，以及控制文件的大小，开启gzip压缩等，但是这些又是生产环境所必须的，所以这些必须的配置webpack已经做了很多，但是有些还是需要我们根据自己需要手动配置。]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2019%2F01%2F12%2Fnodestudynotes%2Fmysql%2F</url>
    <content type="text"><![CDATA[mysql 基本语法查询 mysql是对大小写不敏感的，所以大小写都可以 查询表中所有字段(users，orders为表名，以下相同)select * from users; 根据id查询select * from users where id=?; 根据查找范围查询select * from users where user.age between age1 and age2;选取介于两个值之间的 (包含两个临界值) 数据范围内的值。这些值可以是数值、文本或者日期。 根据排序查询select * from users order by user.age desc;desc是降序，asc是升序 查询限定条目select * from users limit 5;从users表中查询五条数据 模糊查询SELECT * FROM users WHERE name LIKE &#39;%mysql%&#39;;查询users表中name包含mysql的数据 连表查询 (根据users表中的id和orders表中的userId相同查询)select * from users left join orders on users.id=orders.userId 连表查询并排序select * from users left join orders on users.id=orders.userId order by users.age desc; 连表查询 (选取users表中的所有字段，并且只取orders表中的title字段)select users.*,orders.title from users left join orders on users.id = orders.userId 插入数据 插入一条数据insert into users values(name,age,...);如果不指定要插入数据的列名需要列出插入行的每一列数据(包括定义的自增id)；insert into users(name,age,...) values(&#39;mysql&#39;,20,...); 更新数据 根据id更新数据update users set name=&#39;mysql,age=20 where id=?&#39;; (如果不指定where条件，会更新整张表，切记： 在更新记录时要格外小心！执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。) 在 MySQL 中可以通过设置 sql_safe_updates 这个自带的参数来解决，当该参数开启的情况下，你必须在update 语句后携带 where 条件，否则就会报错 删除数据 删除数据delete from users 或者delete * from users where name=&#39;mysql&#39;m,and age=16;(WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！，在删除记录时要格外小心！但是配合事务可以回滚数据) 一般我们用软删除 软删除是对于这条记录做一个标记，比如用户名这一条数据我们可以加一个isDel这个字段，当为1时表示存在，当为0时表示删除，在我们查询的时候我们过滤掉isDel为0的数据即可，在执行操作的时候我们用update语句update users set isDel=0 where id=?聚合函数(不统计null值) 求和select sum(price) from orders;获取某个值(price)的总和 平均数select avg(price) from orders;获取所有price的平均值(不包括null值); 计数select count(*) from orders;获取数据的总条数； 最大值select max(price) from orders;获取最大值,min相同 分组 添加分组ALTER TABLE orders ADD group_id VARCHAR(32);在orders表中添加分组group_id; 设置group_idupdate orders set group_id=?; 根据条件查询select avg(price) from orders group by group_id having avg(price)&gt;3000;查询以group_id分组的平均值大于3000的平均价格； 总结： (顺序一般如下排列) select 后面跟查询的字段 from 后面跟表名 where 查询条件 group by 分组名称 having 分组后带有条件的只能使用hanving order by 必须放到最后面]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习(进阶)]]></title>
    <url>%2F2019%2F01%2F12%2Fnodestudynotes%2Fnodeadvanced%2F</url>
    <content type="text"><![CDATA[node + ejs + express 的使用 项目初始化 npm init -y 安装express、ejs、mysql、 npm i express ejs mysql -S; 在根目录创建入口文件app.js、views文件夹：主要放模板页面，router文件夹：主要放路由相关，controller文件夹：主要放业务逻辑，model文件夹：主要数据操作，static文件夹：主要放静态资源，node_modules主要放npm安装包 目录结构如下app.js 主要开启服务器1234567891011121314151617181920212223242526272829//引入第三方框架expressconst express = require('express');//node的内置模块const path = require('path');//解析请求发送过来的数据let bodyParser = require('body-parser');//开启一个服务let app = express();// 引入模板let ejs = require('ejs');// 设置模板引擎 可以使用html为模板app.engine('.html',ejs.__express);app.set('view engine','html');//设置模板文件存放的路径app.set('views','views');// 解析请求过来的参数 要在路由解析之前注册 req.body这个只针对post请求的，如果是get请求使用req.queryapp.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json());// 引入路由模块let indexRouter = require('./router/indexRouter.js');//注册路由模块app.use(indexRouter);// 挂载静态资源 静态资源可以挂载多个app.use('/node_modules', express.static(path.join(__dirname, 'node_modules')));app.use('/static', express.static(path.join(__dirname, 'static')));//监听端口app.listen(3000,()=&gt;&#123; console.log('node Server Running at http://127.0.0.1:3000');&#125;) router文件夹 router可以放多个路由模块针对不同的模块 router.js 主要负责路由的分发12345678910111213//主要使用express的路由模块const express = require('express');//路由生成let router = express.Router();// 业务逻辑模块let indexController = require('../controller/indexController.js')//路由模块支持链式调用 后面用的是回调是一个命名函数router.get('/',indexController.showIndexPage) .get('/home',indexController.showHomePage) .post('/user',indexController.showUsers)//最后导出这个模块供app.js使用，module.exports 是node的模块化module.exports = router; controller文件夹 controller文件夹主要放业务逻辑的，也可以分模块放多个模块 以indexController为列：indexController.js 接上面的业务模块1234567891011121314151617181920212223242526272829//引入的数据模块let indexModel = require('../model/indexModel.js');//导出的各个模块module.exports = &#123; //渲染首页的 showIndexPage(req,res)&#123; //获取请求的参数 let params = req.query; console.log('params :', params); indexModel.getAllUsers((err,results)=&gt;&#123; //处理错误的 if(err) return res.render('index',&#123;title:'首页',userList:[&#123;name:'暂时没有数据'&#125;]&#125;) //渲染函数，express已经封装好了 res.render('index',&#123;title:'首页',userList:results&#125;) &#125;) &#125;, showHomePage(req,res)&#123; let params = req.query; console.log('home-get:', params); // console.log('req :', req); res.render('home',&#123;title:'home'&#125;) &#125;, showUsers(req,res)&#123; //解析客户端发送的数据的，也就是body-parser，数据会挂载在req.body上 let params = req.body; console.log('user-post:', params); &#125;&#125; model文件夹 存放和数据库交互的模块数据的存取，更新，增加等 一般我们会抽离成一个基本的配置文件和不同模块的数据 baseDB.js 配置文件 12345678910111213//引入mysql模块，这里使用mysqlvar mysql = require('mysql')//创建一个mysql连接，var connection = mysql.createConnection(&#123;host : 'localhost',//使用本地数据库user : 'root',//数据库的用户名password : 'root',//数据库的密码database : 'users',//数据库的名称&#125;);//连接connection.connect()//导出module.exports = connection; indexModel.js 数据交互 1234567891011121314//引入配置文件创立数据库连接let connection = require('./baseDB');module.exports = &#123; getAllUsers(callback)&#123; //mysql的操作语句，后面单独写 let sqlStr = 'select * from users'; //根据语句查询，这里如果是更新或者其他数据操作，需要业务模块传数据过来 connection.query(sqlStr,(err,result)=&gt;&#123; // console.log(result); if(err) return callback(err); callback(null,result) &#125;) &#125;&#125; 总结 上面的整个过程和之前写过的node(基础) 封装过程差不多，主要是express已经封装好了可以直接拿来用 app.js–&gt;router.js–&gt;controller–&gt;model–&gt;controller–&gt;客户端 说一下如果是自己写写东西用的工具 数据库mysql phpstudy 这个工具挺好用的 navicat premium 这个是数据库可视化工具，可以操作数据库]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习(基础)]]></title>
    <url>%2F2019%2F01%2F12%2Fnodestudynotes%2Fnodebasis%2F</url>
    <content type="text"><![CDATA[node基础 Node.js 基于 Chrome V8 引擎的 javascript 运行环境 我们使用的js写的是node代码，只是单纯的字符串， 如果想要解析这些js代码，必须有一个解析执行环境，这个环境就是chrome的v8引擎 Node.js 的包管理器 npm,是全球最大的开源库生态系统 先使用npm init -y初始化包管理文件package.json,将所有安装的包都记录到这个文件中。 在Node中执行js的两种方式 直接输入node，进入Node的REPL运行环境 R:Read:读取用户输入的字符串内容 E:Evaluate:把用户输入的字符串，当作JS代码解析执行， P:Print:打印输出Evaluate解析的结果 L:Loop:进入下一次循环 将代码写在js文件中，使用node指定文件名运行。 文件操作 如果不指定读取的编码格式，默认data就是一个二进制的Buffer对象(读取文件) 12345let fs = require('fs'); fs.readFile('./demo/1.txt','utf-8',(err,data)=&gt;&#123; if(err) throw err; console.log(data); &#125;); 写入文件不用指定编码，默认就是utf-8,后写入的会把之前的覆盖，如果指定的路径不存在则先创建这个文件，如果文件已存在则直接覆盖这个文件; 1234fs.writeFile('./demo/2.txt','这是写入的内容',err=&gt;&#123; // 写入文件，如果写入成功err是null,否则是一个Error对象； !err&amp;&amp;console.log(err);&#125;) 直接在后面追加内容,如果追加的文件不存在会先创建这个文件 1234fs.appendFile('./demo/2.txt','\n这是appendFile的内容',err=&gt;&#123; // if(err) throw err; console.log(err);&#125;) path 处理模块路径的 一般情况下用的最多的是 path.join(path),path.resolve(path),path.basename(path),path.extname(path) path.join() 返回拼接的路径 如：path.join(&#39;/static&#39;,&#39;img&#39;,&#39;..&#39;) 返回’/static’,..会向上一级抵消掉img目录 path.resolve()方法将路径或路径片段的序列解析为绝对路径。零长度的 path 片段会被忽略。如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径。path.resolve(‘/foo/bar’, ‘./baz’);// 返回: ‘/foo/bar/baz’path.resolve(‘/foo/bar’, ‘/tmp/file/‘);// 返回: ‘/tmp/file’ path.basename() 返回 path 的最后一部分path.basename(‘/foo/bar/baz/asdf/quux.html’);// 返回: ‘quux.html’path.basename(‘/foo/bar/baz/asdf/quux.html’, ‘.html’);// 返回: ‘quux’ path.extname()返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束path.extname(‘index.html’); // 返回: ‘.html’ path.extname(‘index.coffee.md’); // 返回: ‘.md’ path.extname(‘index.’); // 返回: ‘.’ path.extname(‘index’); // 返回: ‘’ path.extname(‘.index’); // 返回: ‘’ http (接下来详细说一下封装的过程) 使用http模块创建一个服务器12345678//引入http模块const http = require('http');const app = http.createServer((req,res)=&gt;&#123; res.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //如果不设置中文会乱码 res.end('test页面')&#125;).listen(3000)# 这样一个简单的服务器就创建好了，但是要想做一个网站应用，这是远远不够的 路由 请求地址，也就是我们的请求路由，这个可以在req,请求体身上拿到123456789101112# 由http的服务器说起const http = require('http');# 引入路由模块const router = require('./router.js');const app = http.createServer((req,res)=&gt;&#123; //我们可以看一下这个请求的路径 下图中可以看到挂载的数据有很多，我只截取我们用到的 # 这样我们就可以看到请求的路径和请求的方法了，这时候我们可以创建一个路由模块，然后把req,res传递过去 这里的req，res贯穿整个应用，可以说是一条线把整个应用连接起来--&gt; 建立router.js router.getRoute(req,res) //res.writeHead(200, &#123;'Content-Type': 'text/html; charset = utf-8'&#125;) //res.end('test')&#125;).listen(3000) router.js(接上面路由模块)1234567891011121314151617 module.exports=&#123; getRoute(req,res)&#123; console.log(req.url); const url = req.url; res.writeHead(200, &#123;'Content-Type':'text/html;charset=utf-8'&#125;) if(url==='/')&#123; res.end('首页') &#125;else&#123; res.end(404) &#125; &#125;&#125;这样一个简单的路由就实现了思路：创建一个服务，我们不能把所有的代码都放到server中，这样的话sever中比较杂乱不好维护既然node是服务端的，我们就借鉴服务端的思想分离router模块形成一个单独的模块更加容易维护httpServer--&gt;router 调用router中的方法就可，下面我们继续抽离业务逻辑模块 controller(业务逻辑) 先说一下后台的思想MVC，M–&gt;(model) 数据层只提供数据怎么使用不管，这样可以保证模块功能单一，只提供数据，一般情况下是mysql,monogodb等获取相关的数据，数据操作，V–&gt;view 页面层也就是我们常说的视图，C–&gt;(controller)也就是我们的业务逻辑层，负责调用model模块获取数据 创建我们的controller.js 123456 module.exports = &#123; showIndexPage(req,res)&#123; res.end('首页') &#125;&#125;//这个模块中我们只写业务逻辑，比如我们渲染页面，返回页面和数据，数据的二次封装等 router.js中引入controller.js 123456789101112131415// 引入controller.js let controller = require(&apos;./controller&apos;); module.exports=&#123; getRoute(req,res)&#123; console.log(req.url); const url = req.url; res.writeHead(200, &#123;&apos;Content-Type&apos;:&apos;text/html;charset=utf-8&apos;&#125;) if(url===&apos;/&apos;)&#123; controller.showIndexPage(req,res) // res.end(&apos;首页&apos;) &#125;else&#123; res.end(404) &#125; &#125; &#125; model层 model是负责数据的，一般是和数据库打交道， 1234567891011121314151617181920 var mysql = require('mysql')var connection = mysql.createConnection(&#123;host : 'localhost',user : 'root',password : 'root',database : 'users'&#125;);connection.connect();//一般情况下我们会把上面的配置内容抽离成一个独立的文件，这样方便改配置 module.exports = &#123; getAllData(callback)&#123; let sqlStr = 'select * from users'; connection.query(sqlStr,(err,result)=&gt;&#123; // console.log(result); if(err) return callback(err); callback(null,result) &#125;) &#125;&#125;//在controller.js中引入这个模块直接调用方法即可 ### 总结：抽离的思路就是MVC思想，各个单一的模块负责各自的功能，更易维护 整体的过程：app(server)–&gt;router(路由分发)–&gt;controller(业务逻辑)–&gt;model(数据相关)这个过程中controller负责向客户端发送页面和数据渲染大致的过程就是这样，框架中封装的思想基本上也是这样，只不过细节到位。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(进阶)]]></title>
    <url>%2F2018%2F12%2F21%2Fservice%2F</url>
    <content type="text"><![CDATA[服务 命令行创建ng g s 服务名称 此命令可以创建一个服务，名称前可以加文件夹路径 12345678import &#123; Injectable &#125; from '@angular/core';@Injectable(&#123;providedIn: 'root',&#125;)export class HeroService &#123;constructor() &#123; &#125;&#125; Injectable 这个服务类添加了 @Injectable() 装饰器 为什么要有服务 官方说是：组件不应该直接获取或保存数据，它们不应该了解是否在展示假数据。 它们应该聚焦于展示数据，而把数据访问的职责委托给某个服务。 必须先把服务提供给依赖注入系统 依赖注入(DI)是一种应用设计模式，使用@Injectable()装饰器标记模块，以表明这是一个可注入的模块为组件提供数据 其实依赖注入只做了两件事 初始化被依赖项(引入)，注入到依赖模块中，其实我们经常用的import module from &#39;module&#39;;vue.use(module)、这就是一个依赖注入的实例 新建一个服务，引入服务，在组件的构造器constructor函数中注入服务，利用服务获取数据等，这样是组件和数据解耦，有更高的复用性和维护性 http httpClient 是http的升级版，要使用httpClient要导入HttpClientModule,这个模块在@angular/common/http,在根模块导入，然后在组件中可以注入使用，一般封装之后使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344import &#123; Injectable &#125; from '@angular/core';import &#123; HttpClient, HttpParams &#125; from '@angular/common/http';/*设置请求的基地址，方便替换*/const baseurl = '/api';//启用代理服务@Injectable(&#123;providedIn: 'root'&#125;)export class HttpService &#123;public restServer;// public http;constructor(private Http:HttpClient) &#123; // this.http = Http; this.restServer = baseurl;&#125;public get(url, params?: Object, cb?: Function,options?: Object) &#123; let httpParams = new HttpParams(); const vm = this; if (params) &#123; for (const key in params) &#123; if (params[key] === false || params[key]) &#123; httpParams = httpParams.set(key, params[key]); &#125; &#125; &#125; this.Http.get(this.restServer + url, &#123;params: httpParams&#125;) .subscribe(data =&gt; &#123; cb(data); &#125;);&#125;public post(url, data?: Object, cb?: Function, options?: Object) &#123; const vm = this; this.Http.post(this.restServer + url, data, options) .subscribe(res =&gt; &#123; cb(res); &#125;);&#125;public put(url, data?: Object, cb?: Function, options?: Object) &#123; const vm = this; this.Http.put(this.restServer + url, data, options) .subscribe(res =&gt; &#123; cb(res); &#125;);&#125;&#125; 上面只是一个初步封装的例子，当然还有其它更多的封装情况，切记在app.module.ts中引入httpClientModule模块 http模块有许多设置，包括设置请求头，拦截请求和响应，取消请求，监听进度事件钩子 ngOnChanges()输入属性发生变化时触发， ngOnInit()初始化调用 ngDoCheck()变更检测 ngAfterContentInit()视图渲染完毕触发( Angular 把外部内容投影进组件/指令的视图之后调用) ngAfterContentChecked() 组件变更检测之后触发 ngAfterViewInit()初始化完成之后(组件视图及其子视图)调用 ngAfterViewChecked()组件视图及其子视图变更检测之后调用，ngAterContentChecked()之后 ngOnDestory()组件销毁之前调用]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular服务、依赖注入、http、生命周期钩子函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-表单)]]></title>
    <url>%2F2018%2F11%2F24%2Fforms%2F</url>
    <content type="text"><![CDATA[angular表单 注意:看到很多模板变量报错的，form表单的模块一定要引入正确，在app.module模块引入并不等于全局模式，所以在引入组件的地方一定引入表单的模块,我是在路由模块引入的，因为我的组件多数都在路由文件中；记得不要放在app.module哪个组件需要form模块，就在引入组件的地方引入下面的模块，最后在元数据中imports 1import &#123; FormsModule,ReactiveFormsModule &#125; from '@angular/forms'; 模板驱动表单(FormsModule)angular封装了处理了表单，这里form和原生的不太一样,表单是经过处理的，不会刷新页面 123456789101112131415161718192021222324252627282930313233&lt;form #myForm='ngForm' (ngSubmit)="onSubmit(myForm.value)" novalidate &gt;'这里的模板变量必须是ngForm，表单的内容会以对象的形式挂载在模板变量的value上' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" ngModel name='username' id="username" //'使用ngModel双向绑定数据，必须要有name属性，这个也是挂载模板变量身上的属性名' class="form-control input-underline input-lg" minlength="4" required placeholder="username" #username="ngModel"&gt; '这里的模板变量可以作为提示的判断' &lt;/div&gt; &lt;div [hidden]="username.valid || username.pristine" //'这个是根据模板变量#username="ngModel" 拿到的值 可作为提示用' class="alert alert-danger"&gt; username is required &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" ngModel name='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div ngModelGroup="passwordGroup"&gt;// 'ngModelGroup是用来分组的，可以把多个分成一组放在myForm.value对象的一个属性上' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" ngModel name='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" ngModel name='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 对象的形式模板表单有三个主要的指令 表单的变量 #myForm=’ngForm’ ngForm不可变， ngModel 双向数据绑定，记得name属性ngModelGroup=”passwordGroup” 这个分组用，个人感觉用处不大。 响应式表单(ReactiveFormsModule)demo-template中 1234567891011121314151617181920212223242526&lt;form [formGroup]="myform" (ngSubmit)="onSubmit()"&gt;'视图和myform关联' &lt;div class="form-content"&gt; &lt;div class="form-group" &gt; 用户名&lt;input type="text" formControlName="username" id="username" class="form-control input-underline input-lg" minlength="4" required placeholder="Username" &gt; '使用formControlName绑定字段' &lt;/div&gt; &lt;div class="form-group" &gt; 手机号&lt;input type="text" id="mobeil" formControlName='phone' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" formArrayName='emails'&gt; '使用formArrayName分组数据' &lt;ul&gt; &lt;li *ngFor="let email of myform.get('emails').controls; let i=index"&gt;'获取数组数据并循环' 邮箱-&#123;&#123;i+1&#125;&#125; &lt;input type="text" [formControlName]='i' &gt; &lt;/li&gt; '利用索引绑定数据，记得用[],不知道为什么一会要用[]其他又不用，不得不吐槽一下这个坑爹的angular！！！' &lt;/ul&gt; &lt;button (click)="addEmail()"&gt;add&lt;/button&gt; &lt;/div&gt; &lt;div formGroupName='confirm'&gt;'分组' &lt;div class="form-group" &gt; 密码&lt;input type="password" id="password" formControlName='password' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;div class="form-group" &gt; 确认密码&lt;input type="password" id="cpassword" formControlName='confimp' class="form-control input-underline input-lg" minlength="4" placeholder="Password" &gt; &lt;/div&gt; &lt;/div&gt; &lt;button type="submit" class="btn rounded-btn" &gt;Log in&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 组件中 12345678910111213141516171819202122231. import &#123;FormBuilder, FormControl, FormGroup, FormArray,Validators&#125; from '@angular/forms'; '引入'2. public myform = new FormGroup(&#123; username: new FormControl(), phone: new FormControl(), confirm:new FormGroup(&#123; password: new FormControl(), confimp: new FormControl(), &#125;), emails:new FormArray([ new FormControl(), ]) &#125;); '声明'3. onSubmit()&#123; console.log(this.myform.value); &#125; '数据挂载this.myform.value，是对象形式'4. addEmail()&#123; let emails = this.myform.get('emails') as FormArray; emails.push(new FormControl()) &#125; '这个感觉也是蛮坑的，获取emails数据不能直接取，要用这种方式！！！' 还有很多内容，包括表单校验，FormBuilder服务，校验的内置方法规则，以及自定义校验规则， 但整体感觉相当繁琐，一点都不实用，这里就不做过多介绍，可以去官方文档研究！ 吐槽一下官方文档：文档内容不是很清晰，坑很多，试错成本较大，而且没有常见问题的说明，个人觉得文档很糟糕！！！]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>表单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-路由)]]></title>
    <url>%2F2018%2F11%2F22%2Fbasis-route%2F</url>
    <content type="text"><![CDATA[路由路由配置 123456789101112131415161718192021222324252627&lt;base href="/"&gt; '在index.html的 &lt;head&gt; 标签下先添加一个 &lt;base&gt; 元素，来告诉路由器该如何合成导航用的 URL。'import &#123; RouterModule, Routes &#125; from '@angular/router';'导入router相关模块'const appRoutes: Routes = [ &#123; path: 'hero/:id',component: HeroDetailComponent children:[ &#123; path:'', component: component, &#125;, &#123; path: 'details/:id', component: component, &#125; ] &#125;,'可以用路由传值形如 hero/789' &#123; path: 'heroes',component: HeroListComponent,data: &#123; title: 'Heroes List' &#125; 'data属性存储数据的，' &#125;, &#123; path: '','根路径' redirectTo: '/heroes', pathMatch: 'full' &#125;, &#123; path: '**', component: PageNotFoundComponent &#125;'404路由没匹配上' ];'路由不能有 / 开头' &lt;router-outlet&gt;&lt;/router-outlet&gt; '路由器出口' '说明:如果有子路由跳转要用 ./ 表示子路由' &lt;el-button [routerLink]="['./details',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 路由导航 12345678910111213141516171819202122232425261. &lt;a routerLink="/heroes" routerLinkActive="active"&gt;Heroes&lt;/a&gt; '这种静态路由不需要传值的'2. &lt;el-button [routerLink]="['/singerDetail']" [queryParams]="&#123;id:id&#125;" routerLinkActive="active" type="text" size="small" (click)="handle(scope,2)"&gt;详情&lt;/el-button&gt; 'url路径 /singerDetail?id=xxxxxx'this.singerId = this.routerInfo.snapshot.queryParams['id'];'组件中取值'3. &lt;el-button [routerLink]="['/singerDetail',id]" routerLinkActive="active" type="text" size="small"&gt;详情&lt;/el-button&gt; 'url路径: /singerDetail/xxxxx;注意:这种情况路由中路径设置必须 singerDetail/:id 否则无法匹配无法跳转' this.singerId = this.routerInfo.snapshot.params['id'];'组件中取值' '以上是在模板中绑定跳转'4. this.router.navigate(['/singerDetail'],&#123;queryParams:&#123; id: this.id &#125;&#125;); 'js跳转，和2效果相同组件中取值也是一样' this.router.navigate(['/singerDetail',this.id]);'这个和3效果相同，路由配置也必须一样' '说明: snapshot快照模式，假如你很确定这个组件的实例永远、永远不会被复用，那就可以使用快照， 但是：假如在同一个组件有两个按钮都是去到商品详情点击了第一个按钮并且这个组件没有销毁的情况 下再点击第二个该按钮不会重新创建这个组件的实例的情况下，只是数据传递的不同，这种情况下要使 用订阅模式(subscribe)''以下是两种订阅模式'this.routerInfo.queryParams.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;)'这个对应 /singerDetail?id=xxxxxx' this.routerInfo.params.subscribe((params:ParamMap)=&gt;&#123; this.singerId = params["id"] &#125;) '这个对应 /singerDetail/xxxxxx' '这两个必须对应，否则取不到传的参数' 路由守卫(生命周期钩子) CanActivate: 处理导航到某个路由的情况（进入路由时触发事件）； CanDeactivate: 处理从当前路由离开时的情况（离开当前路由时触发事件）; Resolve: 在路由激活之前获取路由数据（预加载数据）； 以下为例CanActivate守卫文件 guard.ts 如下图 路由文件 使用 最后一定要在路由文件中实例化路由守卫 CanDeactivate 和上面基本相同不再介绍 Resolve例如：查看商品详情时，预先根据该商品id查询返回数据；防止进入商品组件时获取数据延迟而出现页面空白的情况 123resolve:&#123; //resolve是一个对象， 用法都一样 product : ProductResolve //想传入product,product由ProductResolve生成&#125;&#125;,'在app.route.module路由文件中使用，最后记得实例化 ProductResolve']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-内置模块以及语法)]]></title>
    <url>%2F2018%2F11%2F21%2Fbasis%2F</url>
    <content type="text"><![CDATA[从app.module.ts说起 NgModules模块 NgModule 是一些带有 @NgModule 装饰器的类。@NgModule 装饰器的 imports 数组会告诉 Angular 哪些其它的 NgModule 是当前模块 所需的，一般都是在imports数组中放置一些内置模块以及服务。 CommonModule模块 CommonModule 导出所有基本的 Angular 指令和管道 NgIf(判断)、NgForOf(循环，也可用NgFor)、NgClass(添加删除css类)、NgStyle(修改样式)、NgSwitch(和NgIf类似) 等指令(还有更多)，以及一些 CurrencyPipe(数字转金额),DatePipe(日期格式化),DecimalPipe(数字转字符串) 等管道。 FormsModule , ReactiveFormsModule模块 FormsModule 许多和表单相关的指令，后面会详细介绍，ReactiveFormsModule 构建响应式表单，封装了根据规则提示的表单，后面详细介绍。 BrowserModule模块 BrowserModule 运行在浏览器中必须的模块 HttpClientModule模块 HttpClientModule 和服务器通讯的模块，一般是封装在单独的文件中 BrowserAnimationsModule , NoopAnimationsModule模块 BrowserAnimationsModule 开启动画 NoopAnimationsModule 关闭动画 RouterModule模块 RouterModule 路由相关模块 从最简单的说起 插值表达式 123&lt;p&gt;My current hero is &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;img src="&#123;&#123;imageUrl&#125;&#125;" style="height:30px"&gt;&lt;p&gt;The sum of 1 + 1 is not &#123;&#123;1 + 1 + getVal()&#125;&#125;&lt;/p&gt; 支持简单的表达式，不支持赋值运算符，位运算，自增自减等比较复杂的 事件绑定 123&lt;button (click)="deleteHero()"&gt;Delete&lt;/button&gt;&lt;button (click)="onSave($event)"&gt;Save&lt;/button&gt; '$event事件对象'&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt; 和vue差不多，其实很多框架都比较类似，当然也可以用bind-、on-、bindon-前缀绑定 数据绑定 12345678910111213141516171819&lt;img bind-src="imageUrl"&gt;&lt;img [src]="imageUrl"&gt; '属性绑定等价与上面'&lt;button [disabled]="isUnchanged"&gt;Save&lt;/button&gt; '属性绑定'&lt;div [ngClass]="&#123;'special': isSpecial&#125;"&gt;&lt;/div&gt; '类绑定不会覆盖已有的类，只会添加或删除当前类'&lt;input [(ngModel)]="name"&gt; '双向绑定，官方叫她' &gt;&gt;盒子里放香蕉&lt;button [attr.aria-label]="help"&gt;help&lt;/button&gt; '自定义属性等'&lt;div [class.special]="isSpecial"&gt;Special&lt;/div&gt; 'css类名不会覆盖已有的类'&lt;button [style.color]="isSpecial ? 'red' : 'green'"&gt; '行内样式'&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt;&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt;&lt;app-hero-detail [hero]="currentHero"&gt;&lt;/app-hero-detail&gt; '组件传值，方括号一定要有，否则就是字符串了'&lt;div class="bad curly special" [class]="badCurly"&gt;Bad curly&lt;/div&gt; '官方说badCurly有或无会覆盖原有的类 亲测在有[class.special]，[ngClass]同时存在的情况下不会覆盖'&lt;p&gt;&lt;img src="&#123;&#123;heroImageUrl&#125;&#125;"&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;&lt;p&gt;&lt;img [src]="heroImageUrl"&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt; '上面和下面这两种数据绑定作用相同'&lt;p&gt;&lt;span&gt;"&#123;&#123;title&#125;&#125;" is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;"&lt;span [innerHTML]="title"&gt;&lt;/span&gt;" is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt; 模板绑定是通过 property 和事件来工作的(官方介绍的比较详细可以去看官方文档) 结构模板指令 1234567891011121314151617181920212223242526272829303132333435363738&lt;div *ngIf="isActive"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt; 'if判断，必须带*号'&lt;div *ngFor="let hero of heroes"&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt;&lt;app-hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/app-hero-detail&gt;'循环'&lt;div *ngFor="let hero of heroes; let i=index"&gt;&#123;&#123;i + 1&#125;&#125; - &#123;&#123;hero.name&#125;&#125;&lt;/div&gt;'带索引的 必须声明i否则拿不到索引'&lt;el-menu default-active="1" class="el-menu-vertical-demo" theme="dark"&gt; &lt;el-submenu *ngFor="let menu of menuList" [title]="menu.title"&gt; &lt;ng-container *ngIf = "menu.hasChildren;else menuBlock"&gt; &lt;el-menu-item-group *ngFor="let subMenu of menu.subs" &gt; &lt;el-submenu [title]="subMenu.title"&gt; &lt;el-menu-item *ngFor="let subsMenu of subMenu.subMenu" [to]="subsMenu.index"&gt;&#123;&#123;subsMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu-item-group&gt; &lt;/ng-container&gt; &lt;ng-template #menuBlock&gt; &lt;el-menu-item *ngFor="let subMenu of menu.subs" [to]="subMenu.index"&gt;&#123;&#123;subMenu.title&#125;&#125;&lt;/el-menu-item&gt; &lt;/ng-template&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt;'在这种循环和判断的模块中一个元素不能有多个块，上面这个例子，也就是不能把ngIf和ngFor放在同一个元素上否则报错，if判断的else语句使用要用#后面用else的部分'&lt;div *ngFor="let hero of heroes; trackBy: trackByHeroes"&gt; (&#123;&#123;hero.id&#125;&#125;) &#123;&#123;hero.name&#125;&#125;&lt;/div&gt; 'trackBy有点像vue中key但是要声明才能使用'&lt;div [ngSwitch]="currentHero.emotion"&gt; &lt;app-happy-hero *ngSwitchCase="'happy'" [hero]="currentHero"&gt;&lt;/app-happy-hero&gt; &lt;app-sad-hero *ngSwitchCase="'sad'" [hero]="currentHero"&gt;&lt;/app-sad-hero&gt; &lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt; &lt;app-unknown-hero *ngSwitchDefault [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt;&lt;/div&gt; 'ngSwitch指令和js一样的写法'&lt;input #phone placeholder="phone number"&gt; '模板变量可以在其他位置拿到这个元素，以#或者ref声明这个变量'&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt;'模板变量作用整个模板作用域和循环let声明是不同的' 管道操作符 123456789&lt;div&gt;Title through uppercase pipe: &#123;&#123;title | uppercase&#125;&#125;&lt;/div&gt; '用法|后面跟名字即可'&lt;div&gt;Title through a pipe chain:&#123;&#123;title | uppercase | lowercase&#125;&#125;&lt;/div&gt;'可以有多个'&lt;div&gt;Birthdate: &#123;&#123;currentHero?.birthdate | date:'longDate'&#125;&#125;&lt;/div&gt;'传值'&lt;div&gt;&#123;&#123;currentHero | json&#125;&#125;&lt;/div&gt; '调试可以输出整个对象，数组'&lt;div&gt;The name is &#123;&#123;nullHero?.name&#125;&#125;&lt;/div&gt; '安全操作符，当对象nullHero为null时不会报错，这点比vue做的好，当然也可以多级像a?.b?.c?.d这样多级判断'&lt;div&gt; The marker is &#123;&#123;$any(hero).marker&#125;&#125;&lt;/div&gt; '类型转换函数没用过暂时还不是很清楚，官方说防止类型转换错误']]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular(基础篇-文件信息)]]></title>
    <url>%2F2018%2F11%2F12%2Findex%2F</url>
    <content type="text"><![CDATA[文件介绍(angualr-cli生成的项目)生成的项目最外层结构(如图)，主要都集中在src文件夹和angular-cli.json这个文件中 angular-cli.json的主要信息 src目录的主要信息 main.ts入口信息 app目录的主要信息]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular-cli]]></title>
    <url>%2F2018%2F11%2F09%2Fhome%2F</url>
    <content type="text"><![CDATA[写在前面 最近闲着没事，就折腾了一下angular-cli,官方文档anguar-cli, 由于许多东西还在研究，后续持续更新… angular-cli 命令合集项目生成12345$ npm install -g @angular/cli "全局安装"$ ng new myProject "创建新项目 myProject 是项目文件名"$ cd myProject "进入 myProject 文件夹"$ ng server "server/serve都可以，但是我碰到serve启动不成功的情况，这可能和版本更新有关。默认情况下ng会安装依赖，不需要npm install 就可以直接启动"$ ng new myProject --routing "这个命令可以直接生成带有路由的项目，一般都会用的到，当然除了--routing还有其他的参数--prefix组件的前缀" 创建项目具体模块1234567$ ng generate class my-new-class // 新建 class$ ng generate component my-new-component // 新建组件$ ng generate directive my-new-directive // 新建指令$ ng generate enum my-new-enum // 新建枚举$ ng generate module my-new-module // 新建模块$ ng generate pipe my-new-pipe // 新建管道$ ng generate service my-new-service // 新建服务 简写(使用命令的好处是不用在文件来回引入，引入文件很多，很容易遗漏)1234567$ ng g cl my-new-class // 新建 class$ ng g c my-new-component // 新建组件$ ng g d my-new-directive // 新建指令$ ng g e my-new-enum // 新建枚举$ ng g m my-new-module // 新建模块$ ng g p my-new-pipe // 新建管道$ ng g s my-new-service // 新建服务 说明 如果有多个模块，使用命令创建组件要指定组件所属的模块，不指定会默认创建app.module的组件，但是有时候可能会报错。 12$ ng g c my-new-component --module=app-routing // 创建属于路由模块的组件，在路由模块会自动引入该模块$ ng g c my-new-component // 如果不指定模块默认所属在app.module模块中]]></content>
      <categories>
        <category>angular</category>
      </categories>
      <tags>
        <tag>angular命令</tag>
      </tags>
  </entry>
</search>
